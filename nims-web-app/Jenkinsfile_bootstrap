import org.jenkinsci.plugins.workflow.steps.FlowInterruptedException

jenkinsfile_CI = load 'jenkinsfile_CI.groovy'
jenkinsfile_CD = load 'jenkinsfile_CD.groovy'
jenkinsfile_utils = load 'jenkinsfile_utils.groovy'

def checkBuildType() {
    def buildType = "none"
    if ("${env.gitlabActionType}".toString() == "PUSH") {
        buildType = "push_commit_build"
    } else if ("${env.gitlabActionType}".toString() == "MERGE") {
        if ("${env.gitlabMergeRequestState}".toString() == "opened") {
            buildType = "merge_request_build"
        } else if ("${env.gitlabMergeRequestState}".toString() == "closed") {
            buildType = "close_mr_build"
        } else if ("${env.gitlabMergeRequestState}".toString() == "merged") {
            buildType = "accept_mr_build"
        } else {
            buildType = "merge_request_build"
        }
    } else if ("${env.gitlabActionType}".toString() == "NOTE") {
        buildType = "rebuild_merge_request"
    } else if ("${env.gitlabActionType}".toString() == "TAG_PUSH") {
        buildType = "deploy_production"
    }
    return buildType
}

def initGlobalEnv() {
    env.STAGING_IP = ""
    env.MERGE_REQUEST_BUILD_COMMENT = ""
    env.PUSH_COMMIT_BUILD_COMMENT = ""
    env.lastCommitShortName = env.gitlabMergeRequestLastCommit.substring(0, 8)
    env.display_build_name = "${env.gitlabSourceBranch}:${lastCommitShortName} -> ${env.gitlabTargetBranch}".toString()
    if (env.gitlabSourceRepoName != null) {
        env.gitlabSourceRepoName = env.gitlabSourceRepoName.replace(" ", "-")
    }
    if (env.gitlabTargetRepoName != null) {
        env.gitlabTargetRepoName = env.gitlabTargetRepoName.replace(" ", "-")
    }
}

def bootstrap_build() {
    initGlobalEnv()
    env.BUILD_TYPE = checkBuildType()
    echo "BUILD_TYPE = ${env.BUILD_TYPE}"
    switch (env.BUILD_TYPE) {
        case "push_commit_build":
              pipeline()
//            bootstrapPushCommitBuild()
            break
        case "merge_request_build":
            bootstrapMergeRequestBuild()
            break
        case "rebuild_merge_request":
            bootstrapRebuildMergeRequest()
            break
        case "accept_mr_build":
        case "close_mr_build":
            bootstrapAcceptAndCloseMergeRequestBuild()
            break
        case "deploy_production":
            bootstrapDeployToProduction()
            break
        default:
            break
    }
}

def bootstrap_roll_back(){
    env.DEPLOY_RESULT_DESCRIPTION = ""
    loadCIConfigFile()
    try {
        jenkinsfile_CD.rollBackTag()
    }catch (FlowInterruptedException interruptEx){
        echo "${interruptEx}"
        currentBuild.result = "ABORTED"
    }catch (InterruptedException ex){
        currentBuild.result = "ABORTED"
    }catch (err) {
        echo "error: ${err}"
        if (currentBuild.result != "ABORTED") {
            currentBuild.result = "FAILURE"
        }
        env.DEPLOY_RESULT_DESCRIPTION += "<h4>:x: Rollback Final Result: Failed.<h4>"
        throw err
    }
    finally {
        stage("Clean Build Environment") {
            sh 'rm -rf *'
            sh 'rm -rf .git'
        }
        env.DEPLOY_RESULT_DESCRIPTION += "<h4><i><a href='${env.BUILD_URL}display/redirect'>" +
            "Rollback Process Details...</a></i></h4><br/><br/>"
        if (env.GIT_TAG_ROLLBACK == 'Aborted' || env.GIT_TAG_ROLLBACK == ''){
            env.DEPLOY_RESULT_TITLE = "Rollback Tag aborted"
        }else {
            env.DEPLOY_RESULT_TITLE = "Rollback Tag ${env.GIT_TAG_ROLLBACK} result"
        }

        echo "title: ${env.DEPLOY_RESULT_TITLE}"
        echo "description: ${env.DEPLOY_RESULT_DESCRIPTION}"
        withCredentials([string(credentialsId: 'gitlab-floor5-api-token', variable: 'gitlab_api_token')]) {
            def issueContentJson = """
                                    {
                                        "title": "${env.DEPLOY_RESULT_TITLE}",
                                        "description": "${env.DEPLOY_RESULT_DESCRIPTION}",
                                        "labels": "Rollback Result"
                                    }
                                """
            def createIssueResp = httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'POST',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: "PRIVATE-TOKEN", value: "${gitlab_api_token}"]],
                url          : "${env.GITLAB_PROJECT_API_URL}/issues",
                requestBody  : issueContentJson
            ])
            def notifyMemberLevel = 40
            def projectMemberList = jenkinsfile_utils.getProjectMember(notifyMemberLevel)
            def issueCommentStr = ""
            for (member in projectMemberList) {
                issueCommentStr += "@${member} "
            }
            echo "call member: ${issueCommentStr}"
            def issueCreated = jenkinsfile_utils.jsonParse(createIssueResp.content)
            def issueCommentJson = """
                                    {
                                        "body": "${issueCommentStr}"
                                    }
                                """
            httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'POST',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: "PRIVATE-TOKEN", value: "${gitlab_api_token}"]],
                url          : "${env.GITLAB_PROJECT_API_URL}/issues/${issueCreated["iid"]}/notes",
                requestBody  : issueCommentJson
            ])
        }
    }
}

@SuppressWarnings("GroovyUnusedCatchParameter")
def bootstrapPushCommitBuild() {
    loadCIConfigFile()
    env.gitlabBuildID = env.PUSH_BUILD_PREFIX + "-" + env.BUILD_NUMBER

    if (pushCommitInOpenMR(env.gitlabBranch)) {
        stage("Cancel Push commit build") {
            echo "Push branch is in an Open Merge Request. Cancel build"
            currentBuild.result = "ABORTED"
        }
    } else {
        try {
            updateGitlabCommitStatus name: "build", state: 'running'
            updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'running'
            stage('Checkout And Build Source Code') {
                jenkinsfile_utils.checkoutSourceCode("PUSH")
            }
            jenkinsfile_CI.buildPushCommit()

            currentBuild.result = "SUCCESS"
        } catch (FlowInterruptedException interruptEx) {
            currentBuild.result = "ABORTED"
        } catch (InterruptedException ex) {
            currentBuild.result = "ABORTED"
        } catch (err) {
            echo "error: ${err}"
            if (currentBuild.result != "ABORTED") {
                currentBuild.result = "FAILURE"
            }
            throw err
        } finally {
            updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'success'
            if (currentBuild.result != "SUCCESS" && currentBuild.result != "ABORTED") {
                currentBuild.result = "FAILURE"
            }
            def buildIcon = ""
            def buildResultStr = ""
            if (currentBuild.result == "SUCCESS") {
                updateGitlabCommitStatus name: "build", state: 'success'
                buildIcon = ":white_check_mark:"
                buildResultStr = "Build Success. "
            } else if (currentBuild.result == "ABORTED") {
                updateGitlabCommitStatus name: "build", state: 'canceled'
                buildIcon = ":warning:"
                buildResultStr = "Build Canceled."
            } else if (currentBuild.result == "FAILURE") {
                updateGitlabCommitStatus name: "build", state: 'failed'
                buildIcon = ":x:"
                buildResultStr = "Build Fail."
            }
            updateGitlabPushComment(buildIcon, buildResultStr, env.lastCommitShortName)
        }
    }
}

def bootstrapRebuildMergeRequest() {
    loadCIConfigFile()
    if(isOpenMergeRequest(env.gitlabMergeRequestIid)){
        if(isWIPMergeRequest(env.gitlabMergeRequestIid)){
            echo "Rebuild WIP Merge Request. Execute Push Commit Build"
            env.gitlabAfter = env.gitlabMergeRequestLastCommit
            bootstrapPushCommitBuild()
        }else{
            echo "Rebuild Merge Request. Execute Merge Request Build"
            bootstrapMergeRequestBuild()
        }
    }else{
        addGitLabMRComment comment: "This merge request is currently not open. Cancel build"
        currentBuild.result = "ABORTED"
    }
}

def bootstrapMergeRequestBuild() {
    try {
        loadCIConfigFile()
        if (checkIfBranchesRevisionAreSame(env.gitlabSourceBranch, env.gitlabTargetBranch)) {
            stage("Cancel Build When Source Branch is the same with Target Branch") {
                echo "source branch has same commitID with target branch. Stop build"
                env.CHECK_IF_BRANCHES_REVISION_ARE_SAME_RESULT = "Source branch has same commitID with target branch. Stop build"
            }
            throw new InterruptedException("Source branch has same commitID with target branch. Stop build")
        }
        env.gitlabBuildID = env.MR_BUILD_PREFIX + "-" + env.BUILD_NUMBER
        updateGitlabCommitStatus name: "build", state: 'running'
        updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'running'
        stage('Cancel old MR Build') {
            cancelOldMrBuild(env.gitlabMergeRequestIid, env.BUILD_TYPE)
        }
        updateGitlabCommitStatus name: "build", state: 'running'

        stage('Prepare Source code') {
            jenkinsfile_utils.checkoutSourceCode("MERGE")
        }
        jenkinsfile_CI.buildMergeRequest()
        currentBuild.result = "SUCCESS"
    } catch (FlowInterruptedException interruptEx) {
        echo "Build canceled: ${interruptEx}"
        currentBuild.result = "ABORTED"
    } catch (InterruptedException interruptEx) {
        echo "Build canceled: ${interruptEx}"
        currentBuild.result = "ABORTED"
    } catch (err) {
        echo "build error: ${err}"
        if (currentBuild.result != "ABORTED") {
            currentBuild.result = "FAILURE"
        }
        throw err
    } finally {
        def buildIcon = ""
        def buildResultStr = ""
        if (env.sourceBranchCommitID != env.targetBranchCommitID) {
            updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'success'
            if (currentBuild.result != "SUCCESS" && currentBuild.result != "ABORTED") {
                currentBuild.result = "FAILURE"
            }
            if (currentBuild.result == "SUCCESS") {
                updateGitlabCommitStatus name: "build", state: 'success'
                buildIcon = ":white_check_mark:"
                buildResultStr += "Build Success. Staging Environment IP: <b><a href='http://${env.STAGING_IP}'>${env.STAGING_IP}</a></b>"
            } else if (currentBuild.result == "ABORTED") {
                updateGitlabCommitStatus name: "build", state: 'canceled'
                buildIcon = ":warning:"
                buildResultStr = "Build Canceled."
            } else if (currentBuild.result == "FAILURE") {
                updateGitlabCommitStatus name: "build", state: 'failed'
                buildIcon = ":x:"
                buildResultStr = "Build Fail."
            }
        } else {
            if (currentBuild.result == "SUCCESS") {
                buildIcon = ":white_check_mark:"
                buildResultStr += "Build Success. Staging Environment IP: <b><a href='http://${env.STAGING_IP}'>${env.STAGING_IP}</a></b>"
            } else if (currentBuild.result == "ABORTED") {
                buildIcon = ":warning:"
                buildResultStr = "Build Canceled."
            } else if (currentBuild.result == "FAILURE") {
                buildIcon = ":x:"
                buildResultStr = "Build Fail."
            }
        }
        def lastCommitShortName = env.gitlabMergeRequestLastCommit.substring(0, 8)
        def display_build_name = "${env.gitlabSourceBranch}:${lastCommitShortName} -> ${env.gitlabTargetBranch} - ${env.gitlabActionType}".toString()

        def buildSummary = "<summary>$buildIcon Merge request <strong>${display_build_name}</strong>: " +
            "${buildResultStr}</summary>"
        def buildDetail = "<h4><i><a href='${env.BUILD_URL}display/redirect'>" +
            "Build Details...</a></i></h4><br/><br/>"

        echo """
            env.UNIT_TEST_RESULT_STR:  ${env.UNIT_TEST_RESULT_STR}
            env.FUNCTIONAL_TEST_RESULT_STR:  ${env.FUNCTIONAL_TEST_RESULT_STR}
            env.CODE_COVERAGE_RESULT_STR:  ${env.CODE_COVERAGE_RESULT_STR}
            env.CHECK_STYLE_TEST_RESULT_STR:  ${env.CHECK_STYLE_TEST_RESULT_STR}
            env.SONAR_QUBE_SCAN_RESULT_STR:  ${env.SONAR_QUBE_SCAN_RESULT_STR}
            env.PACKAGE_UPLOAD_IMAGE_RESULT_STR:  ${env.PACKAGE_UPLOAD_IMAGE_RESULT_STR}
            env.UPDATE_STAGING_ENV_RESULT_STR:  ${env.UPDATE_STAGING_ENV_RESULT_STR}
        """

        def buildResultContent =
            (env.CANCEL_BUILD_WARNING == null ? "" : env.CANCEL_BUILD_WARNING) +
                (env.CHECK_IF_BRANCHES_REVISION_ARE_SAME_RESULT == null ? "" : env.CHECK_IF_BRANCHES_REVISION_ARE_SAME_RESULT) +
                (env.UNIT_TEST_RESULT_STR == null ? "" : env.UNIT_TEST_RESULT_STR) +
                (env.FUNCTIONAL_TEST_RESULT_STR == null ? "" : env.FUNCTIONAL_TEST_RESULT_STR) +
                (env.CODE_COVERAGE_RESULT_STR == null ? "" : env.CODE_COVERAGE_RESULT_STR) +
                (env.CHECK_STYLE_TEST_RESULT_STR == null ? "" : env.CHECK_STYLE_TEST_RESULT_STR) +
                (env.SONAR_QUBE_SCAN_RESULT_STR == null ? "" : env.SONAR_QUBE_SCAN_RESULT_STR) +
                (env.PACKAGE_UPLOAD_IMAGE_RESULT_STR == null ? "" : env.PACKAGE_UPLOAD_IMAGE_RESULT_STR) +
                (env.UPDATE_STAGING_ENV_RESULT_STR == null ? "" : env.UPDATE_STAGING_ENV_RESULT_STR)

        def mergeRequestBuildStr =
            "<details> ${buildSummary}<br/><br/> ${buildResultContent}" +
                "${buildDetail}</details>".toString()
        echo "comment ${mergeRequestBuildStr}"
        addGitLabMRComment comment: "${mergeRequestBuildStr}"
        echo "comment added !"

        if (currentBuild.result == "FAILURE") {
            // TODO(conghm1) Rollback when build failed
        }
    }
}

def bootstrapAcceptAndCloseMergeRequestBuild() {
    loadCIConfigFile()
    env.gitlabBuildID = env.ACCEPT_CLOSE_MR_BUILD_PREFIX + "-" + env.BUILD_NUMBER
    try {
        updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'running'
        stage('Cancel old MR Build') {
            cancelOldMrBuild(env.gitlabMergeRequestIid, env.BUILD_TYPE)
        }
        jenkinsfile_CI.buildAcceptAndCloseMR()
        currentBuild.result = "SUCCESS"
    } catch (FlowInterruptedException interruptEx) {
        echo "Build canceled: ${interruptEx}"
        currentBuild.result = "ABORTED"
    } catch (InterruptedException interruptEx) {
        echo "Build canceled: ${interruptEx}"
        currentBuild.result = "ABORTED"
    } catch (err) {
        echo "build error: ${err}"
        echo "build result: ${currentBuild.result}"
        if (currentBuild.result != "ABORTED") {
            currentBuild.result = "FAILURE"
        }
        throw err
    } finally {
        // mark that build is done
        updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'success'
        if (currentBuild.result != "SUCCESS" && currentBuild.result != "ABORTED") {
            currentBuild.result = "FAILURE"
        }
    }
}

def bootstrapDeployToProduction() {
    env.DEPLOY_RESULT_DESCRIPTION = ""
    try {
        loadCIConfigFile()
        jenkinsfile_CD.deployToProduction()
        env.DEPLOY_RESULT_DESCRIPTION += "<h4>:white_check_mark: Deploy Final Result: Success.<h4>"
    } catch (FlowInterruptedException interruptEx) {
        echo "${interruptEx}"
        currentBuild.result = "ABORTED"
        env.DEPLOY_RESULT_DESCRIPTION += "<h4>:warning: Deploy Final Result: Aborted.<h4>"
    } catch (InterruptedException ex) {
        echo "${ex}"
        currentBuild.result = "ABORTED"
    } catch (err) {
        echo "${err}"
        echo "build result:"
        echo "${currentBuild.result}"
        if (currentBuild.result != "ABORTED") {
            currentBuild.result = "FAILURE"
            env.DEPLOY_RESULT_DESCRIPTION += "<h4>:x: Deploy Final Result: Failed.<h4>"
        }
        throw err
    } finally {
        stage("Clean Build Environment") {
            sh 'rm -rf *'
            sh 'rm -rf .git'
        }
        env.DEPLOY_RESULT_DESCRIPTION += "<h4><i><a href='${env.BUILD_URL}display/redirect'>" +
            "Deploy Process Details...</a></i></h4><br/><br/>"
        env.DEPLOY_RESULT_TITLE = "Deploy version ${env.project_version} result"

        echo "title: ${env.DEPLOY_RESULT_TITLE}"
        echo "description: ${env.DEPLOY_RESULT_DESCRIPTION}"
        withCredentials([string(credentialsId: 'gitlab-floor5-api-token', variable: 'gitlab_api_token')]) {
            def issueContentJson = """
                                    {
                                        "title": "${env.DEPLOY_RESULT_TITLE}",
                                        "description": "${env.DEPLOY_RESULT_DESCRIPTION}",
                                        "labels": "Deploy Result"
                                    }
                                """
            def createIssueResp = httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'POST',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: "PRIVATE-TOKEN", value: "${gitlab_api_token}"]],
                url          : "${env.GITLAB_PROJECT_API_URL}/issues",
                requestBody  : issueContentJson
            ])
            def notifyMemberLevel = 40
            def projectMemberList = jenkinsfile_utils.getProjectMember(notifyMemberLevel)
            def issueCommentStr = ""
            for (member in projectMemberList) {
                issueCommentStr += "@${member} "
            }
            echo "call member: ${issueCommentStr}"
            def issueCreated = jenkinsfile_utils.jsonParse(createIssueResp.content)
            def issueCommentJson = """
                                    {
                                        "body": "${issueCommentStr}"
                                    }
                                """
            httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'POST',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: "PRIVATE-TOKEN", value: "${gitlab_api_token}"]],
                url          : "${env.GITLAB_PROJECT_API_URL}/issues/${issueCreated["iid"]}/notes",
                requestBody  : issueCommentJson
            ])
        }
    }
}

def loadCIConfigFile() {
    configFileProvider([configFile(fileId: "ci-config-web", targetLocation: 'cicd/')]) {
        load "cicd/ci-config-web"
    }
}

/**
 * Check source branch revision is the same with target branch revision
 * @param branch which this push commit build event push to
 * @return boolean true if this push branch is in a open merge request
 */

def checkIfBranchesRevisionAreSame(sourceBranch, targetBranch) {
    withCredentials([string(credentialsId: "gitlab-floor5-api-token", variable: 'gitlab_api_token')]) {
        def branchPageIndex = 0
        def hasBranchPage = true
        while (hasBranchPage) {
            def branchesResponse = httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'GET',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
                url          : "${env.GITLAB_PROJECT_API_URL}/repository/branches?page=${branchPageIndex}"
            ])
            def branches = jenkinsfile_utils.jsonParse(branchesResponse.content)
            for (branch in branches) {
                if (branch['name'] == sourceBranch) {
                    env.sourceBranchCommitID = branch['commit']['id']
                }
                if (branch['name'] == targetBranch) {
                    env.targetBranchCommitID = branch['commit']['id']
                }
            }
            if (branches.size == 0) {
                hasBranchPage = false
            } else {
                branchPageIndex += 1
            }
        }
    }
    echo "Source Branch Commit ID: ${env.sourceBranchCommitID}"
    echo "Target Branch Commit ID: ${env.targetBranchCommitID}"
    return env.sourceBranchCommitID == env.targetBranchCommitID
}

/**
 * Check if this push commit is in source branch of an Open Merge Request
 * @param branch which this push commit build event push to
 * @return boolean true if this push branch is in a open merge request
 */
def pushCommitInOpenMR(pushBranch) {
    def isInOpenMR = false
    withCredentials([string(credentialsId: "gitlab-floor5-api-token", variable: 'gitlab_api_token')]) {
        def response = httpRequest([
            acceptType   : 'APPLICATION_JSON',
            httpMode     : 'GET',
            contentType  : 'APPLICATION_JSON',
            customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
            url          : "${env.GITLAB_PROJECT_API_URL}/merge_requests?state=opened&source_branch=${pushBranch}"
        ])

        def openMRList = jenkinsfile_utils.jsonParse(response.content)
        if (openMRList.size() > 0) {
            def checkMR = openMRList[0]
            if (checkMR["work_in_progress"] == false) {
                isInOpenMR = true
            }
        }
    }
    return isInOpenMR
}

/**
 * Check if this merge request is a open merge request
 * @param gitlabMergeRequestIid Merge request iid
 * @return boolean true if checked merge request is a open merge request, false if is a closed MR
 */
def isOpenMergeRequest(gitlabMergeRequestIid) {
    withCredentials([
        string(credentialsId: "gitlab-floor5-api-token", variable: 'gitlab_api_token'),
        string(credentialsId: "jenkins-api-token", variable: 'jenkins_api_token')
    ]) {
        def response = httpRequest([
            acceptType   : 'APPLICATION_JSON',
            httpMode     : 'GET',
            contentType  : 'APPLICATION_JSON',
            customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
            url          : "${env.GITLAB_PROJECT_API_URL}/merge_requests/${gitlabMergeRequestIid}"
        ])
        def mergeRequestInfo = jenkinsfile_utils.jsonParse(response.content)
        return (mergeRequestInfo['state']=='opened')
    }
}


/**
 * Check if this merge request is a open and WIP merge request or not
 * @param branch which this push commit build event push to
 * @return boolean true if this push branch is in a open merge request
 */
def isWIPMergeRequest(gitlabMergeRequestIid) {
    withCredentials([
        string(credentialsId: "gitlab-floor5-api-token", variable: 'gitlab_api_token'),
        string(credentialsId: "jenkins-api-token", variable: 'jenkins_api_token')
    ]) {
        def response = httpRequest([
            acceptType   : 'APPLICATION_JSON',
            httpMode     : 'GET',
            contentType  : 'APPLICATION_JSON',
            customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
            url          : "${env.GITLAB_PROJECT_API_URL}/merge_requests/${gitlabMergeRequestIid}"
        ])
        def mergeRequestInfo = jenkinsfile_utils.jsonParse(response.content)
        return mergeRequestInfo['work_in_progress']
    }
}


@SuppressWarnings("GroovyAssignabilityCheck")
def checkIfBuildIsRunning(buildURL) {
    withCredentials([string(credentialsId: "jenkins-api-token", variable: 'jenkins_api_token')]) {
        def buildInfoResp = httpRequest([
            acceptType   : 'APPLICATION_JSON',
            httpMode     : 'GET',
            contentType  : 'APPLICATION_JSON',
            customHeaders: [[name: 'Authorization', value: jenkins_api_token]],
            url          : "${buildURL}/api/json"
        ])
        return jenkinsfile_utils.jsonParse(buildInfoResp.content)["building"] == true
    }
}
/**
 * Check if other builds is running in commit which this build refer to
 * And close these builds when match below requirements:
 * Accept and Close MR build only stop OPEN MR build, not stop Push commit build
 * Open MR Build close both other Open MR build and Push commit build
 * @param buildType type of current build
 * @param gitlabMergeRequestIid GitLab merge request id of this build
 * @return nothing
 */
def cancelOldMrBuild(gitlabMergeRequestIid, currentBuildType) {
    env.CANCEL_BUILD_WARNING = ""
    withCredentials([
        string(credentialsId: "gitlab-floor5-api-token", variable: 'gitlab_api_token'),
        string(credentialsId: "jenkins-api-token", variable: 'jenkins_api_token')
    ]) {
        def pipelines = httpRequest([
            acceptType   : 'APPLICATION_JSON',
            httpMode     : 'GET',
            contentType  : 'APPLICATION_JSON',
            customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
            url          : "${env.GITLAB_PROJECT_API_URL}/merge_requests/${gitlabMergeRequestIid}/pipelines"
        ])

        for (pipeline in jenkinsfile_utils.jsonParse(pipelines.content)) {
            //noinspection GroovyAssignabilityCheck
            def checkCommitID = pipeline['sha']
            echo "check commit id: ${checkCommitID}"
            def commitJobs = httpRequest([
                acceptType   : 'APPLICATION_JSON',
                httpMode     : 'GET',
                contentType  : 'APPLICATION_JSON',
                customHeaders: [[name: 'Private-Token', value: gitlab_api_token]],
                url          : "${env.GITLAB_PROJECT_API_URL}/repository/commits/${checkCommitID}/statuses?all=yes"
            ])

            for (commitJob in jenkinsfile_utils.jsonParse(commitJobs.content)) {
                //noinspection GroovyAssignabilityCheck
                if (currentBuildType == "merge_request_build" || currentBuildType == "rebuild_merge_request"
                    || ((currentBuildType == "accept_mr_build" || currentBuildType == "close_mr_build")
                    && (commitJob["name"].contains(env.MR_BUILD_PREFIX)
                    || commitJob["name"].contains(env.ACCEPT_CLOSE_MR_BUILD_PREFIX)))
                ) {
                    if (commitJob["status"] == "pending" || commitJob["status"] == "running") {
                        def buildURL = commitJob["target_url"].substring(
                            0, commitJob["target_url"].length() - 17)
                        echo "Check buildURL: ${buildURL}"
                        echo "Current buildURL: ${env.BUILD_URL}"
                        if (!env.BUILD_URL.contains(buildURL)) {
                            def retry = 0
                            while (checkIfBuildIsRunning(buildURL) && retry < 3) {
                                echo "Old build: ${commitJob["target_url"]} is running!. Stop this job!"
                                httpRequest([
                                    acceptType   : 'APPLICATION_JSON',
                                    httpMode     : 'POST',
                                    contentType  : 'APPLICATION_JSON',
                                    customHeaders: [[name: 'Authorization', value: jenkins_api_token]],
                                    url          : "${buildURL}/stop"
                                ])
                                sleep 10
                                retry += 1
                            }
                            if (checkIfBuildIsRunning(buildURL)) {
                                env.CANCEL_BUILD_WARNING += "<h2> Build ${buildURL} is still running after cancel build 3 times. Re check it!</h2>"
                            }
                        }
                    }
                }
            }

        }
        echo "pipelines: ${pipelines}"
    }
}


def updateGitlabPushComment(buildIcon, buildResultStr, lastCommitShortName) {

    def buildSummary = "<summary>$buildIcon Push Commit <strong>${env.gitlabSourceBranch}:${lastCommitShortName}</strong>: " +
        "${buildResultStr}</summary>"

    echo """
            env.UNIT_TEST_RESULT_STR:  ${env.UNIT_TEST_RESULT_STR}
            env.FUNCTIONAL_TEST_RESULT_STR:  ${env.FUNCTIONAL_TEST_RESULT_STR}
            env.CODE_COVERAGE_RESULT_STR:  ${env.CODE_COVERAGE_RESULT_STR}
            env.CHECK_STYLE_TEST_RESULT_STR:  ${env.CHECK_STYLE_TEST_RESULT_STR}
            env.SONAR_QUBE_SCAN_RESULT_STR:  ${env.SONAR_QUBE_SCAN_RESULT_STR}
            env.PACKAGE_UPLOAD_IMAGE_RESULT_STR:  ${env.PACKAGE_UPLOAD_IMAGE_RESULT_STR}
            env.UPDATE_STAGING_ENV_RESULT_STR:  ${env.UPDATE_STAGING_ENV_RESULT_STR}
    """

    def buildResultContent =
        (env.UNIT_TEST_RESULT_STR == null ? "" : env.UNIT_TEST_RESULT_STR) +
            (env.CODE_COVERAGE_RESULT_STR == null ? "" : env.CODE_COVERAGE_RESULT_STR) +
            (env.CHECK_STYLE_TEST_RESULT_STR == null ? "" : env.CHECK_STYLE_TEST_RESULT_STR) +
            (env.SONAR_QUBE_SCAN_RESULT_STR == null ? "" : env.SONAR_QUBE_SCAN_RESULT_STR)
    def buildDetails =
        "<h4><i><a href='${env.BUILD_URL}display/redirect'>" +
            "Build Details...</a></i></h4><br/><br/>"
    def buildCommitStr =
        "<details> ${buildSummary}<br/><br/>${buildResultContent}" +
            "${buildDetails}</details>".toString()
    def requestBody = '{"note":"' + buildCommitStr + '", "line_type": "new"}'
    echo "${requestBody}"
    withCredentials([string(credentialsId: 'gitlab-floor5-api-token', variable: 'gitlab_api_token')]) {
        sh "curl -X POST ${env.GITLAB_PROJECT_API_URL}/repository/commits/${env.gitlabAfter}/comments " +
            "-H 'Cache-Control: no-cache' -H 'Content-Type: application/json' " +
            "-H 'PRIVATE-TOKEN: ${gitlab_api_token}' " +
            "-d '${requestBody}' "
    }
}

def pipeline() {
  try {
    stage("load config file"){
      loadCIConfigFile()
      env.gitlabBuildID = env.PUSH_BUILD_PREFIX + "-" + env.BUILD_NUMBER
    }
    stage('Checkout And Build Source Code') {
      jenkinsfile_utils.checkoutSourceCode("PUSH")
    }
    def projectVersion = '1.0.0' //pom.getVersion()
    def dockerImageTag = "${projectVersion}.${env.BUILD_ID}"
    def serviceName = 'nims-web'
//  stages{
//    stage('Unit Test') {
////      unstash 'node_modules'
//      sh 'yarn test:ci'
//      junit 'reports/**/*.xml'
//    }
//    stage('E2E Test') {
////      unstash 'node_modules'
//      sh 'mkdir -p reports'
//      sh 'yarn e2e:pre-ci'
//      sh 'yarn e2e:ci'
//      sh 'yarn e2e:post-ci'
//      junit 'reports/**/*.xml'
//    }
    stage("Package & Build Staging Docker Image") {
      sh """
            chmod +x build.sh
            echo 'IMAGE_STAGING_REGISTRY_URL=${env.DOCKER_STAGING_PUSH_REGISTRY}' >> .env
            echo 'IMAGE_TYPE=${env.STAGING_IMAGE_TYPE}' >> .env
            echo 'STACK_VERSION=${dockerImageTag}' >> .env
            echo 'TAG=${dockerImageTag}' >> .env
            ./build.sh service-stack-build --staging
        """
    }
    stage('View Docker Image') {
      sh 'docker images'
    }
    stage('Upload artifacts to Docker repository') {
      def uploadSuccessComment = "<b>Build & package Artifact Results - " +
        "Staging Image for services is created. " +
        "Download it by command:</b><br/><br/> "

      withDockerRegistry([
        credentialsId: 'nexus-repo-credentials',
        url          : "http://${env.DOCKER_STAGING_PUSH_REGISTRY}"]) {
//        for (def i = 0; i < serviceList.size(); i++) {
//          def serviceName = serviceList.get(i)
        def stagingImage = docker.image("${env.DOCKER_STAGING_PUSH_REGISTRY}/${PROJECT_CODE}/" +
          "${env.STAGING_IMAGE_TYPE}/nims-web:${dockerImageTag}")
        stagingImage.push()
        uploadSuccessComment += "- <i>docker pull ${env.DOCKER_STAGING_PULL_REGISTRY}/nims/" +
          "${env.DOCKER_STAGING_PULL_REGISTRY}/${serviceName}:${dockerImageTag}</i>" +
          "<br/>"
//        }
      }
      sh './build.sh service-stack-down --staging'
      env.PACKAGE_UPLOAD_IMAGE_RESULT_STR = uploadSuccessComment
    }

//    if (env.gitlabTargetBranch == env.STAGING_BRANCH) {
//      tasks['Create Or Update Staging Env'] = {
        stage("Ensure Staging Environment is created") {
          stagingPublicIP = updateStagingEnv("create")
        }
//      }
//    }

//    parallel tasks

//    if (env.gitlabTargetBranch == env.STAGING_BRANCH) {
      stage("Deploy to Staging") {
        echo "${serviceList}"
        withCredentials([sshUserPrivateKey(
          credentialsId: 'staging-private-key',
          keyFileVariable: 'stagingSSHPrivateKeyPath',
          usernameVariable: 'stagingSSHUserName'
        )]) {
          docker.image(env.ANSIBLE_CENTOS7_IMAGE).inside("-v '/tmp/facts_cache:/tmp/facts_cache:rw'") {
            dir('cicd/continous-integration/ansible') {
              def currentDir = pwd()
              sh """
                            ansible-playbook -i jenkins_localhost.ini \
                                utilities.yml --tags prepare-staging-key-inventory\
                                -e SSH_USER_NAME=${stagingSSHUserName} \
                                -e SSH_PRIVATE_KEY_PATH=${stagingSSHPrivateKeyPath} \
                                -e STAGING_PUBLIC_IP=${stagingPublicIP} \
                                -e CURRENT_JENKINS_LOCAL_DIR=${currentDir}

                            ansible-playbook\
                                -i staging_hosts.ini deploy_staging.yml\
                                -e '{ "SERVICE_LIST":${serviceList}}'\
                                -e WORKING_DIR=${env.STAGING_WORKING_DIR}\
                                -e CURRENT_JENKINS_LOCAL_DIR=${currentDir}\
                                -e IMAGE_REGISTRY_URL=${env.DOCKER_MAIN_PULL_REGISTRY}\
                                -e IMAGE_STAGING_REGISTRY_URL=${env.DOCKER_STAGING_PULL_REGISTRY}\
                                -e IMAGE_TYPE=${env.STAGING_IMAGE_TYPE}\
                                -e STACK_VERSION=${dockerImageTag}\
                                -e '{ "REFRESH_SERVICE_LIST_TIMEOUT":${
                env.REFRESH_SERVICE_LIST_TIMEOUT
              }}'
                        """
            }
          }
        }
        env.STAGING_IP = "${stagingPublicIP}"
        env.UPDATE_STAGING_ENV_RESULT_STR = "<br/>:information_source: " +
          "Staging Environment is created at IP: " +
          "<b><a href='http://${stagingPublicIP}'>${stagingPublicIP}</a></b><br/><br/>"
      }

//      stage("Perform Functional Test") {
//        try {
//          sh """
//                        ./build.sh functional_test http://${stagingPublicIP}:8060
//                    """
//        } catch (err) {
//          echo "${err}"
//        } finally {
//          def exists = fileExists 'newman'
//          if (exists) {
//            junit 'newman/test-result-*.xml'
//          }
//
//          def unitTestResult = [
//            "passed" : env.UNIT_TEST_PASSED,
//            "failed" : env.UNIT_TEST_FAILED,
//            "skipped": env.UNIT_TEST_SKIPPED,
//            "total"  : env.UNIT_TEST_TOTAL
//          ]
//
//          def functionalTestResult = getFunctionalTestStatus(unitTestResult)
//          def functionalTestResultString = "- Passed: <b>${functionalTestResult['passed']}</b> <br/>" +
//            "- Failed: <b>${functionalTestResult['failed']}</b> <br/>" +
//            "- Skipped: <b>${functionalTestResult['skipped']}</b> <br/>"
//          def testResultComment = "<b>Functional Test Result:</b> <br/><br/>" +
//            "${functionalTestResultString}" +
//            "<i><a href='${env.BUILD_URL}testReport/'>Details Funcational Test Report...</a></i><br/><br/>"
//          env.FUNCTIONAL_TEST_RESULT_STR = testResultComment
//          if (functionalTestResult.failed > 0) {
//            error "Failed ${functionalTestResult.failed} functional tests"
//          }
//        }
//      }
//    }
//  }
//  stages {
//    stage('Fetch dependencies') {
//      agent {
//        docker 'circleci/node:9.3-stretch-browsers'
//      }
//      steps {
//        sh 'yarn'
//        stash includes: 'node_modules/', name: 'node_modules'
//      }
//    }
//    stage('Lint') {
//        unstash 'node_modules'
//        sh 'yarn lint'
//    }
//    stage('Unit Test') {
//        unstash 'node_modules'
//        sh 'yarn test:ci'
//        junit 'reports/**/*.xml'
//    }
//    stage('E2E Test') {
//        unstash 'node_modules'
//        sh 'mkdir -p reports'
//        sh 'yarn e2e:pre-ci'
//        sh 'yarn e2e:ci'
//        sh 'yarn e2e:post-ci'
//        junit 'reports/**/*.xml'
//    }
//    stage('Compile') {
//      agent {
//        docker 'circleci/node:9.3-stretch-browsers'
//      }
//      steps {
//        unstash 'node_modules'
//        sh 'yarn build:prod'
//        stash includes: 'dist/', name: 'dist'
//      }
//    }
//    stage('Build and Push Docker Image') {
//      agent any
//      environment {
//        DOCKER_PUSH = credentials('docker_push')
//      }
//      steps {
//        unstash 'dist'
//        sh 'docker build -t $DOCKER_PUSH_URL/frontend .'
//        sh 'docker login -u $DOCKER_PUSH_USR -p $DOCKER_PUSH_PSW $DOCKER_PUSH_URL'
//        sh 'docker push $DOCKER_PUSH_URL/frontend'
//      }
//    }
//  }

    updateGitlabCommitStatus name: "${env.gitlabBuildID}", state: 'success'
    if (currentBuild.result != "SUCCESS" && currentBuild.result != "ABORTED") {
      currentBuild.result = "FAILURE"
    }
    def buildIcon = ""
    def buildResultStr = ""
    if (currentBuild.result == "SUCCESS") {
      updateGitlabCommitStatus name: "build", state: 'success'
      buildIcon = ":white_check_mark:"
      buildResultStr = "Build Success. "
    } else if (currentBuild.result == "ABORTED") {
      updateGitlabCommitStatus name: "build", state: 'canceled'
      buildIcon = ":warning:"
      buildResultStr = "Build Canceled."
    } else if (currentBuild.result == "FAILURE") {
      updateGitlabCommitStatus name: "build", state: 'failed'
      buildIcon = ":x:"
      buildResultStr = "Build Fail."
    }
    updateGitlabPushComment(buildIcon, buildResultStr, env.lastCommitShortName)
  } finally {
    stage("Clean Build Environment") {
      sh 'rm -rf *'
      sh 'rm -rf .git'
    }
  }
}

def updateStagingEnv(updateAction) {
  def stagingPublicIP = ""
  def actionTags = ""

  if (updateAction == "create") {
    actionTags = "create-staging-stack"
  } else if (updateAction == "destroy") {
    actionTags = "destroy-staging-stack"
  } else {
    error "Input action is not valid"
  }

  withCredentials([usernamePassword(
    credentialsId: 'openstack_staging_auth_credential_floor5',
    usernameVariable: 'openstack_username',
    passwordVariable: 'openstack_password')]) {
    docker.image(env.ANSIBLE_CENTOS7_IMAGE).inside("-v '/tmp/facts_cache:/tmp/facts_cache:rw'") {
      dir('cicd/continous-integration/ansible') {
        def stagingStackName = "${env.gitlabTargetRepoName}-" +
          "${env.gitlabSourceBranch}-${env.gitlabTargetBranch}-staging".replace("/", "-")
        sh """
                    ansible-playbook -i jenkins_localhost.ini\
                        deploy_staging_heat_stack.yml --tags ${actionTags}\
                        -e stack_name=${stagingStackName}  \
                        -e server_name=${env.gitlabTargetRepoName}-${env.gitlabMergeRequestIid}\
                        -e openstack_username=${openstack_username}\
                        -e openstack_password=${openstack_password}\
                        -e gitlab_merge_source_branch=${env.gitlabSourceBranch}\
                        -e gitlab_merge_target_branch=${env.gitlabTargetBranch}\
                        -e gitlab_project_api_url=${env.GITLAB_PROJECT_API_URL}\
                        -e openstack_staging_auth_url=${env.OPENSTACK_STAGING_AUTH_URL}\
                        -e staging_ssh_key=${env.STAGING_SSH_KEY}\
                        -e staging_flavor=${env.STAGING_FLAVOR}\
                        -e staging_image=${env.STAGING_IMAGE}\
                        -e staging_public_net_id=${env.STAGING_PUBLIC_NET_ID}\
                        -e staging_public_subnet_id=${env.STAGING_PUBLIC_SUBNET_ID}\
                        -e staging_private_net_id=${env.STAGING_PRIVATE_NET_ID}\
                        -e staging_private_subnet_id=${env.STAGING_PRIVATE_SUBNET_ID}\
                        -e staging_user_domain_name=${env.OPENSTACK_STAGING_USER_DOMAIN_NAME}\
                        -e staging_project_domain_name=${env.OPENSTACK_STAGING_PROJECT_DOMAIN_NAME}\
                        -e staging_project_name=${env.OPENSTACK_STAGING_PROJECT_NAME}
                """
        if (updateAction == "create") {
          def staging_info = jenkinsfile_utils.jsonParse(readFile(file: 'staging_server_ip.json'))
          for (output in staging_info) {
            if (output['output_key'] == "staging_server_public_ip") {
              echo " staging public ip: ${output['output_value']}"
              stagingPublicIP = output['output_value']
            }
          }
        }
      }
    }
  }
  return stagingPublicIP
}

return [
    bootstrap_build: this.&bootstrap_build,
    bootstrap_roll_back: this.&bootstrap_roll_back
]
